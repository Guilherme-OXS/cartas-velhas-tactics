<!DOCTYPE html>
<html lang="pt-pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <meta name="description" content="Cartas Velhas: Cyberpunk Tactics. Uma reinven√ß√£o estrat√©gica 3D multiplayer do Jogo da Velha com cartas, poderes e f√≠sica. Jogue gr√°tis online.">
    <meta name="keywords" content="Cartas Velhas, Cyberpunk Tactics, Jogo da Velha 3D, Jogo de Estrat√©gia, Multiplayer P2P, Guilherme Ot√°vio Xavier de Souza, Browser Game, WebGL">
    <meta name="author" content="Guilherme Ot√°vio Xavier de Souza">
    <meta name="robots" content="index, follow">

    <meta property="og:title" content="Cartas Velhas: Cyberpunk Tactics">
    <meta property="og:description" content="Desafia os teus amigos neste jogo t√°tico 3D. Regra do Infinito, Cartas Especiais e Multiplayer em tempo real.">
    <meta property="og:type" content="website">

    <title>Cartas Velhas: Cyberpunk Tactics v0.9.9</title>
    <style>
        /* --- CORE STYLES --- */
        body { margin: 0; overflow: hidden; background-color: #050510; font-family: 'Segoe UI', Tahoma, monospace; user-select: none; touch-action: none; }
        
        /* Scanlines */
        body::after {
            content: " "; display: block; position: absolute; top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 900; background-size: 100% 2px, 3px 100%; pointer-events: none;
        }

        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; z-index: 10; }
        .pointer-events-auto { pointer-events: auto; }

        :root { --x-color: #ff0055; --o-color: #00e5ff; --card-bg: rgba(10, 10, 20, 0.90); }

        /* --- UI COMPONENTS --- */
        .cyber-panel {
            background: rgba(0, 0, 0, 0.9); border: 1px solid #333; border-left: 4px solid var(--o-color);
            padding: 30px; max-width: 600px; width: 90%; position: relative;
            box-shadow: 0 0 20px rgba(0, 229, 255, 0.1); backdrop-filter: blur(5px);
            transform: skewX(-2deg);
        }
        
        .title-glitch { 
            font-size: 3.5rem; font-weight: 900; color: #fff; text-align: center; line-height: 0.9; 
            text-shadow: 3px 3px 0px var(--x-color); margin-bottom: 20px; text-transform: uppercase;
            animation: glitch-anim 3s infinite alternate;
        }

        .cyber-btn { 
            background: transparent; border: 1px solid var(--o-color); color: var(--o-color); 
            padding: 12px 30px; font-size: 1rem; font-weight: bold; letter-spacing: 2px; cursor: pointer; 
            margin: 8px; transition: 0.2s; text-transform: uppercase; min-width: 200px; 
            position: relative; overflow: hidden; display: inline-block;
            transform: skewX(-10deg);
        }
        .cyber-btn span { display: block; transform: skewX(10deg); }
        .cyber-btn:hover { background: var(--o-color); color: #000; box-shadow: 0 0 15px var(--o-color); }
        .cyber-btn.secondary { border-color: #666; color: #aaa; }
        .cyber-btn.secondary:hover { border-color: #fff; color: #fff; background: #222; }

        .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle at center, rgba(26,26,46,0.8) 0%, #000 100%); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; transition: opacity 0.5s; opacity: 1; visibility: visible; }
        .hidden { opacity: 0; visibility: hidden; pointer-events: none; transition: 0.5s; }

        /* Scrollbar Customizada */
        .scroll-content {
            max-height: 50vh; overflow-y: auto; padding-right: 15px; text-align: left;
            scrollbar-width: thin; scrollbar-color: var(--o-color) #111;
            pointer-events: auto; /* Garante scroll no mobile */
        }
        .scroll-content::-webkit-scrollbar { width: 6px; }
        .scroll-content::-webkit-scrollbar-track { background: #111; }
        .scroll-content::-webkit-scrollbar-thumb { background-color: var(--o-color); border-radius: 3px; }

        .update-block { margin-bottom: 20px; border-bottom: 1px dashed #333; padding-bottom: 15px; }
        .update-title { color: var(--o-color); font-weight: bold; font-size: 1rem; margin-bottom: 5px; text-transform: uppercase; }
        .update-item { color: #ccc; font-size: 0.85rem; margin-bottom: 3px; display: block; }
        .update-item::before { content: "> "; color: #666; }

        /* HUD & GAMEPLAY */
        .hud-top { padding: 10px; display: flex; flex-direction: column; align-items: center; background: linear-gradient(to bottom, rgba(0,0,0,0.95), transparent); width: 100%; }
        .scores { display: flex; gap: 30px; margin-top: 5px; align-items: center; justify-content: center; width: 100%; }
        .player-score { transition: 0.3s; opacity: 0.4; transform: scale(0.9); display: flex; flex-direction: column; align-items: center; }
        .player-score.active-turn { opacity: 1; transform: scale(1.1); text-shadow: 0 0 10px currentColor; }
        .score-val { font-size: 2.5rem; font-weight: 900; }
        .player-name { font-size: 0.7rem; color: #fff; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; }
        
        .timer-container { width: 80%; max-width: 300px; height: 4px; background: #222; margin-top: 15px; }
        .timer-bar { width: 100%; height: 100%; background: var(--o-color); transition: width 0.1s linear; box-shadow: 0 0 10px var(--o-color); }

        .hand-wrapper { position: absolute; bottom: 20px; width: 100%; display: flex; justify-content: center; perspective: 1000px; z-index: 10; }
        .hand-container { display: flex; gap: 10px; padding: 10px; }
        .card { 
            width: 80px; height: 110px; background: var(--card-bg); border: 1px solid #444; border-top: 2px solid #666;
            display: flex; flex-direction: column; align-items: center; justify-content: center; color: #fff; cursor: pointer;
            transition: all 0.2s; position: relative; box-shadow: 0 5px 15px rgba(0,0,0,0.6); 
        }
        .card:hover { transform: translateY(-15px); border-color: #fff; z-index: 50; box-shadow: 0 0 20px rgba(255,255,255,0.2); }
        .card.selected { transform: translateY(-25px); border-color: var(--o-color); box-shadow: 0 0 25px var(--o-color); }
        .card.common { border-bottom: 3px solid #888; }
        .card.rare { border-bottom: 3px solid #00ff88; }
        .card.legendary { border-bottom: 3px solid #bd00ff; border-color: #bd00ff; }
        .card-icon { font-size: 2rem; margin-bottom: 5px; }
        .card-name { font-size: 0.6rem; font-weight: 800; text-transform: uppercase; }

        .input-code { background: rgba(0,0,0,0.5); border: 1px solid #555; padding: 10px; font-size: 1.2rem; color: #fff; text-align: center; letter-spacing: 3px; text-transform: uppercase; width: 220px; margin-bottom: 15px; outline: none; font-family: monospace; }
        #hint-pill { position: absolute; top: 120px; background: rgba(0,0,0,0.8); border: 1px solid var(--o-color); color: #fff; padding: 5px 15px; border-radius: 4px; font-size: 0.8rem; transform: translateY(-20px); opacity: 0; transition: 0.3s; pointer-events: none; letter-spacing: 2px; }
        #hint-pill.active { transform: translateY(0); opacity: 1; }
        
        #toast-msg { position: absolute; top: 40%; width: 100%; text-align: center; font-size: 3rem; font-weight: 900; color: #fff; text-shadow: 0 0 20px var(--x-color); opacity: 0; pointer-events: none; transition: 0.3s; z-index: 200; transform: scale(0.5); }
        #toast-msg.show { transform: scale(1); opacity: 1; }
        
        @keyframes glitch-anim { 0% { text-shadow: 3px 3px 0px var(--x-color); } 20% { text-shadow: -3px -3px 0px var(--o-color); } 40% { text-shadow: 2px -2px 0px #fff; } 100% { text-shadow: 3px 3px 0px var(--x-color); } }
        .loader { width: 30px; height: 30px; border: 2px solid #333; border-top: 2px solid var(--o-color); border-radius: 50%; animation: spin 0.8s infinite; margin: 10px auto; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        
        .credits-name { color: var(--o-color); font-weight: bold; font-size: 1.2rem; margin: 10px 0; display: block; text-shadow: 0 0 10px var(--o-color); }
        .match-log { color: #aaa; font-family: monospace; font-size: 0.8rem; margin-top: 10px; height: 20px; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
</head>
<body>

    <div id="canvas-container" style="position: absolute; top:0; left:0; width:100%; height:100%;"></div>

    <div id="ui-layer" class="hidden">
        <div class="hud-top pointer-events-auto">
            <div style="font-size:0.7rem; color:#666; letter-spacing:2px; cursor:pointer;" onclick="copyCode()">SALA: <span id="room-code" style="color:#fff;">---</span></div>
            <div id="hint-pill">Sua Vez</div>
            <div class="scores">
                <div id="p1-score" class="player-score"><div class="score-val" style="color:var(--x-color)">0</div><div class="player-name" id="name-x">P1</div></div>
                <div style="font-size:1.5rem; color:#444;">//</div>
                <div id="p2-score" class="player-score"><div class="score-val" style="color:var(--o-color)">0</div><div class="player-name" id="name-o">P2</div></div>
            </div>
            <div class="timer-container"><div id="timer-bar" class="timer-bar"></div></div>
        </div>
        <div id="toast-msg">TOAST</div>
        <div class="hand-wrapper"><div id="hand-container" class="hand-container pointer-events-auto"></div></div>
        <button onclick="quitGame()" class="cyber-btn secondary pointer-events-auto" style="position:absolute; top:10px; right:10px; min-width:auto; padding:5px 15px; font-size:0.7rem;"><span>SAIR</span></button>
    </div>

    <div id="screen-menu" class="screen">
        <div class="cyber-panel" style="text-align: center; border:none; background:transparent; box-shadow:none;">
            <div class="title-glitch">CARTAS<br>VELHAS</div>
            <p style="letter-spacing: 5px; color: var(--o-color); margin-bottom: 30px; font-size: 0.8rem;">TACTICAL SYSTEM v0.9.9 (BETA)</p>
            
            <input type="text" id="my-name-input" class="input-code" style="width: 200px; border-color: var(--o-color);" maxlength="10" placeholder="SEU NICKNAME" value="PLAYER">
            <br>
            <button class="cyber-btn" onclick="startQuickMatch()"><span>‚ö° PARTIDA R√ÅPIDA</span></button>
            <br>
            <button class="cyber-btn secondary" onclick="openScreen('screen-lobby-custom')"><span>CRIAR / ENTRAR</span></button>
            <br>
            <div style="margin-top: 10px;">
                <button class="cyber-btn secondary" style="min-width: 100px; font-size: 0.8rem;" onclick="openScreen('screen-credits')"><span>CR√âDITOS</span></button>
                <button class="cyber-btn secondary" style="min-width: 100px; font-size: 0.8rem;" onclick="openScreen('screen-updates')"><span>UPDATES</span></button>
            </div>
        </div>
    </div>

    <div id="screen-credits" class="screen hidden">
        <div class="cyber-panel">
            <h2 style="color:#fff; margin-top:0;">CR√âDITOS</h2>
            <div style="color:#ccc; text-align:center;">
                DESENVOLVIDO POR:
                <span class="credits-name">Guilherme Ot√°vio<br>Xavier de Souza</span>
                <hr style="border-color:#333; margin: 20px 0;">
                <p>Engine: Three.js WebGL</p>
                <p>Network: PeerJS P2P</p>
                <p>Audio: WebAudio API Synth</p>
            </div>
            <center><button class="cyber-btn secondary" onclick="openScreen('screen-menu')"><span>VOLTAR</span></button></center>
        </div>
    </div>

    <div id="screen-updates" class="screen hidden">
        <div class="cyber-panel">
            <h2 style="color:#fff; margin-top:0;">SYSTEM LOG</h2>
            
            <div class="scroll-content">
                <div class="update-block">
                    <div class="update-title">v0.9.9 - Restaura√ß√£o</div>
                    <span class="update-item">Corre√ß√£o Cr√≠tica: Matchmaking revertido para l√≥gica est√°vel.</span>
                    <span class="update-item">Implementado Jitter (atraso aleat√≥rio) para evitar conflitos.</span>
                </div>
                <div class="update-block">
                    <div class="update-title">v0.8.0 - Cyber Polish</div>
                    <span class="update-item">Menu Principal estilo "Terminal Hacker".</span>
                    <span class="update-item">Efeitos visuais (Scanlines, Ilumina√ß√£o Volum√©trica).</span>
                    <span class="update-item">C√¢mara orbital no menu principal.</span>
                </div>
                <div class="update-block">
                    <div class="update-title">v0.7.0 - Expans√£o Mobile & Matchmaking</div>
                    <span class="update-item">Partida R√°pida: Algoritmo autom√°tico de busca de salas.</span>
                    <span class="update-item">Suporte Mobile Real: Toque e redimensionamento corrigidos.</span>
                    <span class="update-item">Resili√™ncia: Tratamento de desconex√µes.</span>
                </div>
                <div class="update-block">
                    <div class="update-title">v0.6.0 - Polimento de Jogabilidade</div>
                    <span class="update-item">Handshake Robusto: Confirma√ß√£o de conex√£o.</span>
                    <span class="update-item">Feedback Visual: Glitch na pe√ßa mais antiga.</span>
                    <span class="update-item">Revanche: Bot√£o para reiniciar partida instantaneamente.</span>
                    <span class="update-item">Auto-Jogada por tempo limite.</span>
                </div>
                <div class="update-block">
                    <div class="update-title">v0.5.0 - Multiplayer P2P</div>
                    <span class="update-item">Conex√£o Direta: Implementa√ß√£o do PeerJS.</span>
                    <span class="update-item">Sistema de Salas Privadas.</span>
                    <span class="update-item">Sincroniza√ß√£o Total em tempo real.</span>
                </div>
                <div class="update-block">
                    <div class="update-title">v0.4.0 - Sistema de Cartas</div>
                    <span class="update-item">Introdu√ß√£o do Deck Building (M√£o de Cartas).</span>
                    <span class="update-item">Novas Cartas: Escudo, Mover e Trocar.</span>
                    <span class="update-item">Sistema Anti-Bloqueio.</span>
                </div>
                <div class="update-block">
                    <div class="update-title">v0.3.0 - A Revolu√ß√£o 3D</div>
                    <span class="update-item">Migra√ß√£o para Three.js (WebGL).</span>
                    <span class="update-item">Ilumina√ß√£o n√©on din√¢mica e plataforma flutuante.</span>
                    <span class="update-item">C√¢mara Cinem√°tica.</span>
                </div>
                <div class="update-block">
                    <div class="update-title">v0.2.0 - A√ß√£o e "Sumo"</div>
                    <span class="update-item">Poderes Iniciais: Bomba e Hack.</span>
                    <span class="update-item">Efeitos: Screen shake e part√≠culas.</span>
                    <span class="update-item">√Åudio: Sintetizador interno.</span>
                </div>
                <div class="update-block" style="border:none;">
                    <div class="update-title">v0.1.0 - A Base</div>
                    <span class="update-item">Mec√¢nica Principal: Regra do Infinito.</span>
                    <span class="update-item">Visual 2D Inicial.</span>
                </div>
            </div>
            <center><button class="cyber-btn secondary" style="margin-top:20px;" onclick="openScreen('screen-menu')"><span>VOLTAR</span></button></center>
        </div>
    </div>

    <div id="screen-lobby-custom" class="screen hidden">
        <h2 style="color:#fff;">MODO PRIVADO</h2>
        <button class="cyber-btn" onclick="openLobby('host')"><span>CRIAR SALA</span></button>
        <button class="cyber-btn" onclick="openLobby('join')"><span>ENTRAR COM C√ìDIGO</span></button>
        <br><br>
        <button class="cyber-btn secondary" onclick="openScreen('screen-menu')"><span>VOLTAR</span></button>
    </div>

    <div id="screen-lobby-wait" class="screen hidden">
        <h2 style="color:#fff;">LOBBY</h2>
        
        <div id="lobby-host-ui" class="hidden" style="text-align:center;">
            <p style="color:#aaa;">PARTILHE ESTE C√ìDIGO</p>
            <div id="display-code" class="input-code" style="border:none; cursor:pointer;" onclick="copyCode()">...</div>
            <p style="color:var(--o-color); animation: pulse-border 1s infinite; padding: 5px;">Aguardando oponente...</p>
        </div>
        
        <div id="lobby-client-ui" class="hidden" style="text-align:center;">
            <p style="color:#aaa;">DIGITE O C√ìDIGO</p>
            <input type="text" id="input-code" class="input-code" maxlength="6" placeholder="XXXXXX">
            <br><button id="btn-connect" class="cyber-btn" onclick="connectToHost()"><span>CONECTAR</span></button>
            <p id="client-status" class="match-log"></p>
        </div>

        <div id="lobby-quick-ui" class="hidden" style="text-align:center;">
            <p style="color:#00ff88; font-weight:bold;">BUSCANDO PARTIDA</p>
            <div class="loader"></div>
            <p id="quick-log" class="match-log">A iniciar...</p>
        </div>

        <button class="cyber-btn secondary" onclick="location.reload()" style="margin-top:30px;"><span>CANCELAR</span></button>
    </div>

    <div id="screen-gameover" class="screen hidden">
        <h1 id="winner-text" class="title-glitch" style="font-size:3rem;">VENCEDOR</h1>
        <div id="rematch-area"></div>
        <button class="cyber-btn secondary" onclick="location.reload()" style="margin-top:20px;"><span>SAIR</span></button>
    </div>

<script>
    // --- HELPERS UI ---
    function resetLobbyUI() {
        document.getElementById('lobby-host-ui').classList.add('hidden');
        document.getElementById('lobby-client-ui').classList.add('hidden');
        document.getElementById('lobby-quick-ui').classList.add('hidden');
    }

    function openScreen(screenId) {
        document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
        const target = document.getElementById(screenId);
        if(target) target.classList.remove('hidden');
        if(audioCtx.state === 'suspended') audioCtx.resume();
    }

    // --- AUDIO SYSTEM ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const SoundFX = {
        playTone: (freq, type, duration, vol=0.1) => {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
            osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + duration);
        },
        hover: () => SoundFX.playTone(400, 'sine', 0.1, 0.05),
        click: () => SoundFX.playTone(800, 'triangle', 0.1, 0.1),
        place: () => SoundFX.playTone(600, 'sine', 0.3, 0.2),
        explode: () => { SoundFX.playTone(100, 'sawtooth', 0.4, 0.3); },
        roundWin: () => { [440, 554, 659].forEach((f, i) => setTimeout(() => SoundFX.playTone(f, 'square', 0.4, 0.2), i*100)); },
        matchWin: () => { [440, 554, 659, 880, 1100].forEach((f, i) => setTimeout(() => SoundFX.playTone(f, 'square', 0.6, 0.3), i*150)); }
    };

    // --- GAME DATA ---
    const CARDS = {
        'PLACE': { name: 'B√°sica', icon: '‚ôüÔ∏è', rarity: 'common', weight: 45 },
        'BOMB': { name: 'Bomba', icon: 'üí£', rarity: 'rare', weight: 15 },
        'SHIELD': { name: 'Escudo', icon: 'üõ°Ô∏è', rarity: 'rare', weight: 15 },
        'MOVE': { name: 'Mover', icon: 'üîÑ', rarity: 'rare', weight: 15 },
        'SWAP': { name: 'Trocar', icon: 'üîÅ', rarity: 'legendary', weight: 10 }
    };

    const GameState = {
        board: Array(9).fill(null),
        history: { 'X': [], 'O': [] },
        hands: { 'X': [], 'O': [] },
        shields: {},
        scores: { 'X': 0, 'O': 0 },
        names: { 'X': 'P1', 'O': 'P2' },
        turn: 'X',
        winner: null,
        targetWins: 3,
        winningLine: null
    };

    // --- NETWORKING (PEERJS) ---
    const APP_ID = "cv-tactics-final-v2-"; 
    const MAX_PUB_ROOMS = 20; 
    
    let peer, conn, mySide = null, isHost = false;
    let timeLeft = 16, myName = "PLAYER", isQuickMatch = false;
    let selectedHandIdx = null, activeCardType = null, stepSourceIdx = null;
    let particles = [], cameraShake = 0;
    let isInGame = false;

    function initPeer(id = null) { return new Peer(id, { debug: 1 }); }

    function updateName() {
        myName = document.getElementById('my-name-input').value.trim() || "PLAYER";
        if(myName.length > 10) myName = myName.substr(0,10);
    }

    function openLobby(mode) {
        updateName();
        openScreen('screen-lobby-wait');
        resetLobbyUI();

        if (mode === 'host') setupHostPrivate(); 
        else if (mode === 'join') document.getElementById('lobby-client-ui').classList.remove('hidden');
    }

    // --- HOST PRIVADO ---
    function setupHostPrivate() {
        isHost = true; mySide = 'X';
        resetLobbyUI();
        document.getElementById('lobby-host-ui').classList.remove('hidden');
        
        const code = Math.random().toString(36).substr(2, 6).toUpperCase();
        document.getElementById('display-code').innerText = code;
        GameState.names['X'] = myName;
        peer = initPeer(APP_ID + code);
        peer.on('error', () => setupHostPrivate());
        peer.on('connection', handleConnectionRequest);
    }

    // --- CLIENTE PRIVADO ---
    function connectToHost() {
        updateName();
        const code = document.getElementById('input-code').value.trim().toUpperCase();
        if (code.length < 4) return;
        const btn = document.getElementById('btn-connect');
        const stat = document.getElementById('client-status');
        btn.disabled = true; btn.innerText = "..."; stat.innerText = "A conectar...";
        
        if(peer) peer.destroy();
        peer = initPeer();
        peer.on('open', () => {
            conn = peer.connect(APP_ID + code, { reliable: true });
            configureConnection();
            setTimeout(() => { if(!conn.open) { btn.disabled = false; btn.innerText = "CONECTAR"; stat.innerText = "Sala n√£o encontrada."; } }, 5000);
        });
    }

    // --- PARTIDA R√ÅPIDA (MATCHMAKING ZIG-ZAG ROBUSTO) ---
    function startQuickMatch() {
        updateName();
        isQuickMatch = true;
        openScreen('screen-lobby-wait');
        resetLobbyUI();
        document.getElementById('lobby-quick-ui').classList.remove('hidden');
        document.getElementById('quick-log').innerText = "Iniciando...";
        
        // Jitter: Atraso aleat√≥rio para evitar colis√£o
        const randomDelay = Math.floor(Math.random() * 1500);
        setTimeout(() => findPublicMatch(0), randomDelay);
    }

    function findPublicMatch(roomIndex) {
        if(roomIndex >= MAX_PUB_ROOMS) {
            document.getElementById('quick-log').innerText = "Servidores cheios.";
            // Fallback para privado
            setTimeout(() => {
                document.getElementById('quick-log').innerText = "Criando sala manual...";
                setupHostPrivate();
            }, 1500);
            return;
        }

        const roomID = APP_ID + 'PUB-' + roomIndex;
        document.getElementById('quick-log').innerText = `Verificando Sala ${roomIndex + 1}...`;

        // 1. TENTA SER HOST (CRIAR SALA)
        if(peer) peer.destroy();
        peer = initPeer(roomID);

        // Sucesso: Virei Host!
        peer.on('open', () => {
            document.getElementById('quick-log').innerText = `Sala ${roomIndex + 1} Criada! Aguardando...`;
            isHost = true; mySide = 'X'; GameState.names['X'] = myName;
            
            peer.on('connection', (c) => {
                if(conn && conn.open) { 
                    c.on('open', () => { c.send({type:'ROOM_FULL'}); setTimeout(()=>c.close(),500); }); 
                    return; 
                }
                handleConnectionRequest(c);
            });
        });

        // Erro: Sala ocupada (ID indispon√≠vel) -> TENTA ENTRAR
        peer.on('error', (err) => {
            if(err.type === 'unavailable-id') {
                console.log(`Sala ${roomIndex} ocupada. Tentando entrar...`);
                connectToPublicRoom(roomID, roomIndex);
            } else {
                console.log("Erro rede, pr√≥xima sala.");
                findPublicMatch(roomIndex + 1);
            }
        });
    }

    function connectToPublicRoom(roomID, currentIdx) {
        // Cria um peer tempor√°rio para ser cliente
        const tempPeer = initPeer();
        
        tempPeer.on('open', () => {
            conn = tempPeer.connect(roomID, { reliable: true });
            
            // Conectou!
            conn.on('open', () => {
                console.log("Entrou na sala!");
                isHost = false; mySide = 'O';
                conn.send({ type: 'JOIN_HANDSHAKE', name: myName });
                setupClientListener();
            });

            // Rejeitado (Sala Cheia)
            conn.on('data', (data) => {
                if(data.type === 'ROOM_FULL') {
                    console.log("Sala cheia, pr√≥xima...");
                    conn.close();
                    tempPeer.destroy();
                    findPublicMatch(currentIdx + 1);
                } else handleData(data);
            });

            // Timeout (Host fantasma/crashou)
            setTimeout(() => {
                if(!conn.open) {
                    console.log("Sem resposta. Pr√≥xima...");
                    tempPeer.destroy();
                    findPublicMatch(currentIdx + 1);
                }
            }, 2000);
        });
    }

    // --- HANDLERS ---
    function handleConnectionRequest(c) {
        conn = c;
        conn.on('data', (data) => {
            if(data.type === 'JOIN_HANDSHAKE') { GameState.names['O'] = data.name; startGame(); }
            else handleData(data);
        });
        conn.on('close', () => { showToast("OPONENTE SAIU", "#ff0000"); setTimeout(()=>location.reload(), 3000); });
    }

    function configureConnection() { conn.on('open', () => { conn.send({ type: 'JOIN_HANDSHAKE', name: myName }); setupClientListener(); }); }
    function setupClientListener() { conn.on('data', handleData); conn.on('close', () => { showToast("DESCONECTADO", "#ff0000"); setTimeout(()=>location.reload(), 3000); }); }

    function handleData(data) {
        if (data.type === 'STATE_UPDATE') syncState(data.state, data.serverTime);
        else if (data.type === 'ACTION' && isHost) processAction(data.action, 'O');
        else if (data.type === 'TOAST') showToast(data.msg, data.color);
        else if (data.type === 'RESTART' && !isHost) openScreen('ui-layer');
    }

    // --- GAMEPLAY ---
    function startGame() { GameState.scores = { 'X': 0, 'O': 0 }; resetMatch(); }
    function resetMatch() { resetBoard(); GameState.winner = null; GameState.hands = { 'X': generateHand(), 'O': generateHand() }; GameState.turn = 'X'; broadcastState(); if(isHost) sendData({ type: 'RESTART' }); }
    function resetBoard() { GameState.board.fill(null); GameState.history = { 'X': [], 'O': [] }; GameState.shields = {}; GameState.winningLine = null; timeLeft = 16; }

    function generateHand() { const h = ['PLACE']; for(let i=0; i<2; i++) h.push(getRandomCard()); return h; }
    function getRandomCard() { const r = Math.random() * 100; let s = 0; for (const [k, d] of Object.entries(CARDS)) { s += d.weight; if (r <= s) return k; } return 'PLACE'; }

    function processAction(action, player) {
        if (GameState.turn !== player || GameState.winningLine) return; 
        let success = false; const { type, target, source, cardIdx } = action;

        if (type === 'PLACE' && GameState.board[target] === null) {
            if (GameState.history[player].length >= 3) GameState.board[GameState.history[player].shift()] = null;
            GameState.board[target] = player; GameState.history[player].push(target); success = true; SoundFX.place();
        } 
        else if (type === 'BOMB' && GameState.board[target] !== null && !isProtected(target)) {
            const v = GameState.board[target]; GameState.board[target] = null; GameState.history[v] = GameState.history[v].filter(i => i !== target);
            success = true; SoundFX.explode(); cameraShake = 0.5; spawnExplosion(target);
        }
        else if (type === 'MOVE' && GameState.board[target] === null) {
            GameState.board[source] = null; GameState.board[target] = player;
            GameState.history[player] = GameState.history[player].filter(i => i !== source); GameState.history[player].push(target); success = true; SoundFX.place();
        }
        else if (type === 'SHIELD' && GameState.board[target] === player) { GameState.shields[target] = 2; success = true; SoundFX.place(); }
        else if (type === 'SWAP' && !isProtected(target) && !isProtected(source)) {
            const enemy = player === 'X' ? 'O' : 'X';
            GameState.board[source] = enemy; GameState.board[target] = player;
            GameState.history[player] = GameState.history[player].map(i => i === source ? target : i);
            GameState.history[enemy] = GameState.history[enemy].map(i => i === target ? source : i); success = true; SoundFX.click();
        }
        else if (type === 'TIMEOUT') { GameState.hands[player].shift(); GameState.hands[player].push('PLACE'); success = true; }

        if (success) {
            if(type !== 'TIMEOUT') { GameState.hands[player].splice(cardIdx, 1); GameState.hands[player].push(GameState.hands[player].includes('PLACE') ? getRandomCard() : 'PLACE'); }
            const winLine = checkRoundWin();
            if (winLine) {
                GameState.winningLine = winLine; const winner = GameState.board[winLine[0]]; GameState.scores[winner]++; SoundFX.roundWin(); cameraShake = 0.8;
                if (GameState.scores[winner] >= GameState.targetWins) { setTimeout(() => { GameState.winner = winner; broadcastState(); }, 2000); }
                else { setTimeout(() => { resetBoard(); GameState.turn = (winner === 'X' ? 'O' : 'X'); broadcastState(); }, 2500); }
            } else {
                GameState.turn = GameState.turn === 'X' ? 'O' : 'X'; for (let k in GameState.shields) if (GameState.shields[k] > 0) GameState.shields[k]--; timeLeft = 15;
            }
            broadcastState();
        }
    }

    function checkRoundWin() {
        const w = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
        for (let c of w) { if (GameState.board[c[0]] && GameState.board[c[0]] === GameState.board[c[1]] && GameState.board[c[0]] === GameState.board[c[2]]) return c; } return null;
    }

    function isProtected(idx) { return GameState.shields[idx] > 0; }
    function broadcastState() { if (conn && conn.open) conn.send({ type: 'STATE_UPDATE', state: GameState, serverTime: timeLeft }); syncState(GameState, timeLeft); }

    function syncState(newState, serverTime) {
        Object.assign(GameState, newState); if (serverTime !== undefined) timeLeft = serverTime;
        document.getElementById('name-x').innerText = GameState.names.X; document.getElementById('name-o').innerText = GameState.names.O;
        if(isQuickMatch) document.getElementById('room-code').innerText = "R√ÅPIDA";
        
        updateVisuals();
        if (GameState.winner) { showGameOver(); return; }
        
        isInGame = true;
        openScreen('ui-layer');
    }

    function showGameOver() {
        isInGame = false;
        openScreen('screen-gameover');
        const wName = GameState.names[GameState.winner];
        document.getElementById('winner-text').innerText = wName + " VENCEU!";
        document.getElementById('winner-text').style.color = (GameState.winner==='X'?'var(--x-color)':'var(--o-color)');
        SoundFX.matchWin();
        const area = document.getElementById('rematch-area'); area.innerHTML = '';
        if(isHost) {
            const btn = document.createElement('button'); btn.className = 'cyber-btn'; btn.innerHTML = '<span>REVANCHE</span>'; btn.onclick = () => { resetMatch(); }; area.appendChild(btn);
        } else area.innerHTML = '<p style="color:#aaa;">Aguardando Host...</p>';
    }

    function sendData(data) { if (conn && conn.open) conn.send(data); }
    function sendAction(a) { if(isHost) processAction(a, 'X'); else { conn.send({ type: 'ACTION', action: a }); } resetSelection(); }
    function resetSelection() { selectedHandIdx=null; activeCardType=null; stepSourceIdx=null; updateHandUI(); document.getElementById('hint-pill').classList.remove('active'); }

    /* =========================================
       THREE.JS VISUALS
       ========================================= */
    const scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x050510, 0.02);
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 100);
    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('canvas-container').appendChild(renderer.domElement);
    const pieceGroup = new THREE.Group(); scene.add(pieceGroup);
    const particlesGroup = new THREE.Group(); scene.add(particlesGroup);

    const gridHelper = new THREE.GridHelper(100, 100, 0x222222, 0x111111);
    gridHelper.position.y = -2; scene.add(gridHelper);

    window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

    const tileGeo = new THREE.BoxGeometry(2.8, 0.2, 2.8);
    const tileMat = new THREE.MeshStandardMaterial({ color: 0x111116, roughness: 0.1, metalness: 0.8 });
    const tiles = [];
    for(let i=0; i<9; i++) {
        const t = new THREE.Mesh(tileGeo, tileMat.clone()); t.position.set((i%3-1)*3.1, 0, (Math.floor(i/3)-1)*3.1); t.userData = { id: i };
        const edges = new THREE.LineSegments(new THREE.EdgesGeometry(tileGeo), new THREE.LineBasicMaterial({color:0x333344, transparent:true, opacity:0.3}));
        t.add(edges); scene.add(t); tiles.push(t);
    }
    
    const dl = new THREE.DirectionalLight(0xffffff, 0.5); dl.position.set(5, 10, 5); scene.add(dl);
    const pl1 = new THREE.PointLight(0xff0055, 1, 30); pl1.position.set(5, 5, 5); scene.add(pl1);
    const pl2 = new THREE.PointLight(0x00e5ff, 1, 30); pl2.position.set(-5, 5, -5); scene.add(pl2);
    scene.add(new THREE.AmbientLight(0xffffff, 0.3));

    function spawnExplosion(idx) {
        const x = (idx%3-1)*3.1; const z = (Math.floor(idx/3)-1)*3.1;
        for(let i=0; i<25; i++) particles.push({ pos: new THREE.Vector3(x, 1, z), vel: new THREE.Vector3((Math.random()-0.5)*0.6, Math.random()*0.6, (Math.random()-0.5)*0.6), life: 1.0, color: 0xffaa00 });
    }
    function spawnWinParticles(idxList) {
        idxList.forEach(idx => {
            const x = (idx%3-1)*3.1; const z = (Math.floor(idx/3)-1)*3.1;
            const color = GameState.board[idx] === 'X' ? 0xff0055 : 0x00e5ff;
            for(let i=0; i<15; i++) particles.push({ pos: new THREE.Vector3(x + (Math.random()-0.5), 2, z + (Math.random()-0.5)), vel: new THREE.Vector3(0, Math.random()*0.2, 0), life: 2.0, color: color, gravity: -0.05 });
        });
    }

    function updateVisuals() {
        camera.userData.targetRot = (mySide==='X') ? 0 : Math.PI;
        pieceGroup.clear();
        if(GameState.winningLine) spawnWinParticles(GameState.winningLine);
        GameState.board.forEach((c, i) => {
            if(c) {
                const x = (i%3-1)*3.1; const z = (Math.floor(i/3)-1)*3.1;
                const isWinner = GameState.winningLine && GameState.winningLine.includes(i);
                let m;
                if(c==='X') {
                    const g = new THREE.Group();
                    const mat = new THREE.MeshStandardMaterial({ color: 0xff0055, emissive: 0xff0055, emissiveIntensity: isWinner ? 5.0 : 1.5 });
                    const b1=new THREE.Mesh(new THREE.BoxGeometry(2,0.4,0.4), mat); b1.rotation.y=Math.PI/4;
                    const b2=new THREE.Mesh(new THREE.BoxGeometry(2,0.4,0.4), mat); b2.rotation.y=-Math.PI/4; g.add(b1); g.add(b2); m=g;
                } else {
                    const mat = new THREE.MeshStandardMaterial({ color: 0x00e5ff, emissive: 0x00e5ff, emissiveIntensity: isWinner ? 5.0 : 1.5 });
                    m=new THREE.Mesh(new THREE.TorusGeometry(0.8, 0.2, 16, 32), mat); m.rotation.x=Math.PI/2;
                }
                m.position.set(x, 1, z);
                if(isWinner) m.userData.spinSpeed = 0.2;
                const isOldest = GameState.history[c][0]===i && GameState.history[c].length===3;
                if(!isWinner && isOldest) m.userData.isGlitching=true; else { m.userData.isGlitching=false; m.visible=true; m.scale.setScalar(1); }
                if(GameState.shields[i]>0) {
                    const s = new THREE.Mesh(new THREE.IcosahedronGeometry(1.2), new THREE.MeshBasicMaterial({color:0x0088ff, wireframe:true, transparent:true, opacity:0.5}));
                    s.userData.anim='shield'; m.add(s);
                }
                pieceGroup.add(m);
            }
        });
        document.getElementById('p1-score').querySelector('.score-val').innerText = GameState.scores.X;
        document.getElementById('p2-score').querySelector('.score-val').innerText = GameState.scores.O;
        const isTurnX = GameState.turn === 'X';
        document.getElementById('p1-score').className = `player-score ${isTurnX?'active-turn':''}`;
        document.getElementById('p2-score').className = `player-score ${!isTurnX?'active-turn':''}`;
        updateHandUI();
    }

    const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2();
    let menuTime = 0;

    function animate() {
        requestAnimationFrame(animate);
        
        if(isInGame) {
            if(cameraShake > 0) {
                cameraShake -= 0.05; if(cameraShake < 0) cameraShake = 0;
                camera.position.x += (Math.random()-0.5) * cameraShake; camera.position.y += (Math.random()-0.5) * cameraShake; camera.position.z += (Math.random()-0.5) * cameraShake;
            }
            const targetRot = camera.userData.targetRot || 0;
            const angle = THREE.MathUtils.lerp(Math.atan2(camera.position.x, camera.position.z), targetRot, 0.05);
            if(cameraShake < 0.1) {
                camera.position.x = Math.sin(angle) * 14; camera.position.z = Math.cos(angle) * 14;
                camera.position.y = THREE.MathUtils.lerp(camera.position.y, 15, 0.1); camera.lookAt(0,0,0);
            }
        } else {
            menuTime += 0.005;
            camera.position.x = Math.sin(menuTime) * 18; camera.position.z = Math.cos(menuTime) * 18;
            camera.position.y = 12; camera.lookAt(0,0,0);
        }

        gridHelper.position.z = (Date.now() * 0.002) % 2;

        pieceGroup.children.forEach(p => {
            p.rotation.y += p.userData.spinSpeed || 0.01;
            if(p.userData.isGlitching) { p.visible = Math.random()>0.1; p.scale.setScalar(0.9+Math.random()*0.2); }
            p.children.forEach(c => { if(c.userData.anim==='shield') c.rotation.z-=0.05; });
        });

        particlesGroup.clear();
        for(let i=particles.length-1; i>=0; i--) {
            const p = particles[i]; p.life -= 0.02; p.pos.add(p.vel); if(p.gravity) p.vel.y += p.gravity;
            if(p.life <= 0) { particles.splice(i,1); continue; }
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.1,0.1), new THREE.MeshBasicMaterial({color:p.color}));
            mesh.position.copy(p.pos); mesh.rotation.x = Math.random()*Math.PI; particlesGroup.add(mesh);
        }
        renderer.render(scene, camera);
    }
    animate();

    setInterval(() => {
        if(!GameState.winner && document.getElementById('screen-lobby-wait').classList.contains('hidden')) {
            if(timeLeft > 0) timeLeft -= 0.1; if(isHost && timeLeft <= 0) processAction({ type: 'TIMEOUT' }, GameState.turn);
            const pct = Math.max(0, (timeLeft/15)*100); document.getElementById('timer-bar').style.width = pct + '%';
        }
    }, 100);

    function handleCardClick(idx, type) {
        if(GameState.turn !== mySide) return; if(selectedHandIdx === idx) { resetSelection(); return; }
        selectedHandIdx=idx; activeCardType=type; stepSourceIdx=null; SoundFX.click(); updateHandUI();
        const hint = { 'PLACE':'Espa√ßo vazio', 'BOMB':'Inimigo', 'SHIELD':'Sua pe√ßa', 'MOVE':'1. Sua pe√ßa', 'SWAP':'1. Inimigo' };
        document.getElementById('hint-pill').innerText = hint[type] || ''; document.getElementById('hint-pill').classList.add('active');
    }

    function updateHandUI() {
        const c = document.getElementById('hand-container'); c.innerHTML='';
        if(!GameState.hands[mySide]) return;
        GameState.hands[mySide].forEach((k,i)=>{
            const d=CARDS[k]; const el=document.createElement('div'); el.className=`card ${d.rarity}`;
            if(i===selectedHandIdx) el.classList.add('selected');
            el.innerHTML=`<div class="card-icon">${d.icon}</div><div class="card-name">${d.name}</div>`;
            el.onclick=()=>handleCardClick(i,k); c.appendChild(el);
        });
    }

    // --- INPUT HANDLING ---
    function onInput(x, y) {
        mouse.x=(x/window.innerWidth)*2-1; mouse.y=-(y/window.innerHeight)*2+1;
        raycaster.setFromCamera(mouse, camera);
        const ints=raycaster.intersectObjects(tiles);
        if(ints.length && activeCardType && GameState.turn===mySide && !GameState.winningLine) {
            const idx=ints[0].object.userData.id;
            const my=GameState.board[idx]===mySide, en=GameState.board[idx]&&!my, emp=!GameState.board[idx];
            if(activeCardType==='PLACE' && emp) sendAction({type:'PLACE', target:idx, cardIdx:selectedHandIdx});
            else if(activeCardType==='BOMB' && en) sendAction({type:'BOMB', target:idx, cardIdx:selectedHandIdx});
            else if(activeCardType==='SHIELD' && my) sendAction({type:'SHIELD', target:idx, cardIdx:selectedHandIdx});
            else if(activeCardType==='MOVE') {
                if(stepSourceIdx===null && my) { stepSourceIdx=idx; document.getElementById('hint-pill').innerText="2. Destino vazio"; }
                else if(stepSourceIdx!==null && emp) sendAction({type:'MOVE', source:stepSourceIdx, target:idx, cardIdx:selectedHandIdx});
            } else if(activeCardType==='SWAP') {
                if(stepSourceIdx===null && en) { stepSourceIdx=idx; document.getElementById('hint-pill').innerText="2. Sua pe√ßa"; }
                else if(stepSourceIdx!==null && my) sendAction({type:'SWAP', source:idx, target:stepSourceIdx, cardIdx:selectedHandIdx});
            }
        }
    }

    window.addEventListener('mousedown', e => { if(e.button===0) onInput(e.clientX, e.clientY); else resetSelection(); });
    
    // --- CORRE√á√ÉO FINAL: SUPORTE MOBILE ---
    // Agora o toque s√≥ conta como input de jogo se for no CANVAS. 
    // Elementos da UI (cartas, bot√µes) usam o clique nativo.
    window.addEventListener('touchstart', e => { 
        if(e.touches.length > 0) {
            if(e.target.tagName === 'CANVAS') { 
                e.preventDefault(); 
                onInput(e.touches[0].clientX, e.touches[0].clientY); 
            }
        }
    }, {passive: false});

    function copyCode() { navigator.clipboard.writeText(document.getElementById('display-code').innerText); showToast("COPIADO", "#fff"); }
    function showToast(m,c) { const t=document.getElementById('toast-msg'); t.innerText=m; t.style.textShadow=`0 0 50px ${c}`; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),2000); }
    function quitGame() { if(conn) conn.close(); location.reload(); }
</script>
</body>
</html>